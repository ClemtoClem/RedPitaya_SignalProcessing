#include "modules.hpp"

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <cmath>
#include <numeric>
#include <complex>
#include <string>
#include <cstring>
#include <chrono>
#include <algorithm>
#include <sys/time.h>
#include <iostream>
#include <iomanip>
#include <time.h>
#include "rp.h"
#include "rp_hw-calib.h"
#include "rp_hw-profiles.h"

#include "Signal.hpp"
#include "Spectrum.hpp"
#include "Filter.hpp"
#include "Demodulator.hpp"
#include "PID.hpp"
#include "CSVFile.hpp"
#include "Noise.hpp"
#include "Window.hpp"
#include "utils.hpp"
#include "globals.hpp"
#include "acquisition.hpp"
#include <stdexcept>

int module_frequencyScanning(const std::vector<std::string> &args) {
	int result;
	
	try {

		SetBufferSize(ADC_BUFFER_SIZE);
		SetDecimation(16);

		// proporiétés du balayage en fréquence
		int frequency_min = 100;
		int frequency_max = 100000;
		int number_of_frequencies_in_the_inteval = 40;

		// propriétés du sinal généré
		float output_amplitude = 1.0f;
		float output_phase  = 0;
		float output_offset = 0;
		
		// propriétés acquisition
		int points_per_period = 100;
		bool hasSetDecimation = false;
		int nb_acquisitions = 10; // nombre d'acquisitions à effectuer pour chaque fréquence
		int delay = 1000;
		float  trigger_level = 0.01f;
		int32_t trigger_delay = BUFFER_SIZE/2;

		// propriété démodulationrp_trig_src_t
		double dem_filter_freq = 1e3;

		// propriété de la fenêtre
		WindowType window_type = WindowType::Rectangular;

		// Taille de la memoire du filtre moyenneur
		int averaging_filter_order = 2; 

		bool mode_debug = true;

		if (args.size() >= 1) {
			for (auto param : args) {
				if (param == "help") {
					std::cerr << "\033[4;0mHelp message\033[0m" << std::endl;
					std::cerr << "Details:" << std::endl;
					std::cerr << "  This module performs a frequency sweep, generating a sequence of" << std::endl;
					std::cerr << "  frequencies on a logarithmic scale at the output of the card," << std::endl;
					std::cerr << "  then performing an acquisition at the input of the card." << std::endl;
					std::cerr << "  " << std::endl;
					std::cerr << "Possibilities of utilisation : " << std::endl;
					std::cerr << "    mode_debug=<boolean>" << std::endl;
					std::cerr << "      details: this is a boolean value, which if true, will display the" << std::endl;
					std::cerr << "      note: this argument is optional, and if not entered, the default value is " << mode_debug << std::endl;
					std::cerr << "  Logarithmic scale for frequency scanning : " << std::endl;
					std::cerr << "    frequency_min=<integer>; fmin=<integer>" << std::endl;
					std::cerr << "      details: this is the minimum frequency of the frequency sweep" << std::endl;
					std::cerr << "      note: this argument is optional, and if not entered, the default value is " << frequency_min << std::endl;
					std::cerr << "    frequency_max=<integer>; fmax=<integer>" << std::endl;
					std::cerr << "      details: this is the maximum frequency of the frequency sweep" << std::endl;
					std::cerr << "      note: this argument is optional, and if not entered, the default value is " << frequency_max << std::endl;
					std::cerr << "    number_of_frequencies_in_the_inteval=<integer>; nfi=<integer>" << std::endl;
					std::cerr << "      details: this is the number of frequencies to scan on the frequency sweep" << std::endl;
					std::cerr << "      note: this argument is optional, and if not entered, the default value is " << number_of_frequencies_in_the_inteval << std::endl;
					std::cerr << "  Generator properties : " << std::endl;
					std::cerr << "    amplitude=<valu>; a=<value>; " << std::endl;
					std::cerr << "      details: this is the amplitude of the signal generated by the card" << std::endl;
					std::cerr << "      note: this argument is optional, and if not entered, the default value is " << output_amplitude << std::endl;
					std::cerr << "    offset=<valeur>; off=<valeur>; " << std::endl;
					std::cerr << "      details: this is the offset of the signal generated by the card" << std::endl;
					std::cerr << "      note: this argument is optional, and if not entered, the default value is " << output_offset << std::endl;
					std::cerr << "    phase=<value>; ph=<value>; " << std::endl;
					std::cerr << "      details: this is the phase of the signal generated by the card" << std::endl;
					std::cerr << "      note: this argument is optional, and if not entered, the default value is " << output_phase << std::endl;
					std::cerr << "  RP properties : " << std::endl;
					std::cerr << "    buffer_size=<integer>; \tbs=<integer>; " << std::endl;
					std::cerr << "      details: this is the buffer size of the acquisition signal" << std::endl;
					std::cerr << "      note: this argument is optional, and if not entered, the default value is " << ADC_BUFFER_SIZE << std::endl;
					std::cerr << "  Acquisition properties : " << std::endl;
					std::cerr << "    delay=<integer µs>" << std::endl;
					std::cerr << "      details: this is the delay between the end of the generation and the start of the acquisition" << std::endl;
					std::cerr << "      note: this argument is optional, and if not entered, the default value is " << delay << std::endl;
					std::cerr << "    window_type=<string>; \twindow=<string>; " << std::endl;
					std::cerr << "      details: this is the type of window to apply to the acquisition signal" << std::endl;
					std::cerr << "      note: this argument is optional, and if not entered, the default value is " << windowTypeToString(window_type) << std::endl;
					std::cerr << "    dem_filter_freq=<integer>; \tdff=<integer>; " << std::endl;
					std::cerr << "      details: this is the frequency of the low pass filter to apply to the demodulation" << std::endl;
					std::cerr << "      note: this argument is optional, and if not entered, the default value is " << dem_filter_freq << std::endl;
					std::cerr << "    averaging_filter_order=<integer>; \tafo=<integer>; " << std::endl;
					std::cerr << "      details: this is the order of the averaging filter" << std::endl;
					std::cerr << "      note: this argument is optional, and if not entered, the default value is " << averaging_filter_order << std::endl;
					std::cerr << "    points_per_period=<integer>; \tppp=<integer>; " << std::endl;
					std::cerr << "      details: this is the number of points per period of the signal" << std::endl;
					std::cerr << "      note: this argument is optional, and if not entered, the default value is " << points_per_period << std::endl;
					std::cerr << "    decimation=<integer>; \tdec=<integer>; " << std::endl;
					std::cerr << "      details: this is the decimation factor of the acquisition signal" << std::endl;
					std::cerr << "      note: this argument is optional, and if not entered, the default value is " << points_per_period << std::endl;
					std::cerr << "    nb_acquisitions=<integer>; \tnba=<integer>; " << std::endl;
					std::cerr << "      details: this is the number of acquisitions to perform by frequency in sweep frequencies" << std::endl;
					std::cerr << "      note: this argument is optional, and if not entered, the default value is " << nb_acquisitions << std::endl;
					std::cerr << "  trigger_level=<float>; trl=<float>" << std::endl;
					std::cerr << "      note: this argument is optional, and if not entered, the default value is " << trigger_level << "." << std::endl;
					std::cerr << "  trigger_delay=<integer>; trd=<integer>" << std::endl;
					std::cerr << "      note: Enter the trigger delay in sample index." << std::endl;
					std::cerr << "            This argument is optional, and if not entered, the default value is " << trigger_delay << "." << std::endl;
					return 0;
				} else {
					// Parse other arguments
					size_t pos = param.find('=');
					if (pos != std::string::npos) {
						std::string name = param.substr(0, pos);
						std::string value = param.substr(pos + 1);

						if (name == "mode_debug") {
							mode_debug = stringToBool(value);
						} else if (name == "frequency_min" || name == "fmin") {
							frequency_min = convertToInteger(value);
						} else if (name == "frequency_max" || name == "fmax") {
							frequency_max = convertToInteger(value);
						} else if (name == "number_of_frequencies_in_the_inteval" || name == "nfi") {
							number_of_frequencies_in_the_inteval = std::abs(std::stoi(value));
						} else if (name == "amplitude" || name == "a") {
							output_amplitude = std::stof(value);
						} else if (name == "phase" || name == "ph") {
							output_phase = std::stof(value);
						} else if (name == "offset" || name == "off") {
							output_offset = std::stof(value);
						} else if (name == "delay") {
							delay = std::abs(convertToInteger(value));
						} else if (name == "window" || name == "win") {
							window_type = stringToWindowType(value);
						} else if (name == "dem_filter_freq" || name == "dff") {
							dem_filter_freq = std::abs(convertToInteger(value));
							if (dem_filter_freq < 500) {
								std::cerr << "The value of the demodulation filter frequency must be greater than 500 Hz" << std::endl;
								dem_filter_freq = 500;
							}
						} else if (name == "averaging_filter_order" || name == "afo") {
							averaging_filter_order = std::abs(convertToInteger(value));
						} else if (name == "points_per_period" || name == "ppp") {
							points_per_period = std::abs(convertToInteger(value));
							if (points_per_period == 0) {
								points_per_period = 1;
							}
						} else if (name == "decimation" || name == "dec") {
							hasSetDecimation = true;
							SetDecimation(std::stoi(value));
						} else if (name == "buffsize" || name == "bs") {
							SetBufferSize(convertToInteger(value));
						} else if (name == "nb_acquisitions" || name == "nba") {
							nb_acquisitions = std::abs(convertToInteger(value));
							if (nb_acquisitions == 0) {
								nb_acquisitions = 1;
							}
						} else if (name == "trigger_level" || name == "trl") {
							trigger_level = std::stof(value);
						} else if (name == "trigger_delay" || name == "trd") {
							trigger_delay = std::stoi(value);
						} else {
							std::cerr << "Error: invalid argument " << param << std::endl;
							return 1;
						}

					} else {
						std::cerr << "Error: invalid argument " << param << std::endl;
						return 1;
					}
				}
			}
		}

		if (frequency_min <= 0 || frequency_max <= 0 || number_of_frequencies_in_the_inteval < 0) {
			std::cerr << "Error: frequency_min, frequency_max and number_of_frequencies_in_the_inteval must be positive" << std::endl;
			return 1;
		}
		if (frequency_min > frequency_max) {
			std::cerr << "Error: frequency_min must be less than frequency_max" << std::endl;
			return 1;
		}

		/* Print error, if rp_Init() function failed */
		if (rp_InitReset(true) != RP_OK) {
			std::cerr << "Error: Rp api init failed!";
			return 1;
		}
		initAcquisition(trigger_level, trigger_delay);
		
		std::cerr << "+----------- START -------------+" << std::endl;
		

		std::cerr << "Create files" << std::endl;

		CSVFile::setTimeToFilepath();
		std::string filename1 = "signals.csv";
		CSVFile outFile1(filename1);
		std::string filename2 = "amplitudes.csv";
		CSVFile outFile2(filename2);
		std::string filename3 = "phases.csv";
		CSVFile outFile3(filename3);
		std::string filename4 = "amplitudeOfMovement.csv";
		CSVFile outFile4(filename4);
		std::string filename5 = "phaseOfMovement.csv";
		CSVFile outFile5(filename5);

		Signal signal1, signal2;
		Signal windowed_signal1, windowed_signal2;
		Signal amplitude_demodulated1, phase_demodulated1;
		Signal amplitude_demodulated2, phase_demodulated2;
		Signal scanning_frequencies(0, "frequency");
		Signal amplitude_of_movement(0, "AmplitudeOfMovement");
		Signal phase_of_movement(0, "PhaseOfMovement");
		Signal bigSignal1(BUFFER_SIZE*nb_acquisitions);
		Signal bigSignal2(BUFFER_SIZE*nb_acquisitions);
		Signal bigAmplitudeDemodulated1(BUFFER_SIZE*nb_acquisitions);
		Signal bigAmplitudeDemodulated2(BUFFER_SIZE*nb_acquisitions);
		Signal bigPhaseDemodulated1(BUFFER_SIZE*nb_acquisitions);
		Signal bigPhaseDemodulated2(BUFFER_SIZE*nb_acquisitions);
		std::vector<Signal> signals;
		std::vector<Signal> amplitudes;

		/* - - - - - - - - - - - - - - - - - - - - - - - */
		/* Initialisation de la plage de fréquences */
		double step = static_cast<double>(frequency_max - frequency_min) / static_cast<double>(number_of_frequencies_in_the_inteval);
		for (double f = static_cast<double>(frequency_min); f <= static_cast<double>(frequency_max); f += step) {
			scanning_frequencies.push_back(std::floor(f));
		}

		/* - - - - - - - - - - - - - - - - - - - - - - - */
		/* Initialisation de la démodulation */
		Demodulator dem;

		/* Initialisation de deux filtres moyenneurs */
		AveragingFilter averaging_filter1;
		AveragingFilter averaging_filter2;
		averaging_filter1.set(averaging_filter_order);
		averaging_filter2.set(averaging_filter_order);

		/* Initialisation de la fenêtre */
		Window window;
		if (!window.set(window_type, BUFFER_SIZE)) {
			std::runtime_error("Unable to set the window function.");
		}
		window.setup();

		std::cerr << "Frequency scanning between " << frequency_min << " Hz to " << frequency_max << " Hz" << std::endl;

		/* - - - - - - - - - - - - - - - - - - - - - - - */
		/* Balayage des fréquences */

		// calculer le temps de montée du signal en fonction de la fréquence du filtre de la démodulation à 3 tau
		double rising_time = 3.0/dem_filter_freq;
		size_t indexRisingTime;
		size_t sizePermanentRegime;
		double amplitude, phase;
		float pourcent = 0;
		double sumAmp = 0, sumPh = 0;
		int i = 0, j = 0;
		double phase_max = -2*M_PI;
		int phase_max_frequency = frequency_min;
		double amplitude_max = 0;
		int amplitude_max_frequency = frequency_min;
		
		rp_GenReset();

		/* Génération du signal sinusoïdal */
		rp_GenWaveform(RP_CH_1, RP_WAVEFORM_SINE);
		rp_GenFreq(RP_CH_1, static_cast<int>(scanning_frequencies[0]));
		rp_GenAmp(RP_CH_1, output_amplitude);
		rp_GenOffset(RP_CH_1, output_offset);
		rp_GenPhase(RP_CH_1, output_phase);
		rp_GenOutEnable(RP_CH_1);
		rp_GenTriggerOnly(RP_CH_1);

		for (double f : scanning_frequencies) {
			rp_GenFreq(RP_CH_1, static_cast<int>(f));
			
			if (!hasSetDecimation) {
				SetDecimation(calculateDecimation(f, points_per_period));
			}
			dem.set(dem_filter_freq, f);
			dem.setup();

			// calculer l'indice de la valeur à la fin du régime transitoire du signal
			indexRisingTime = static_cast<size_t>(std::floor(rising_time * SAMPLING_FREQUENCY));
			sizePermanentRegime = BUFFER_SIZE - indexRisingTime;
			if (indexRisingTime >= BUFFER_SIZE ) {
				std::runtime_error("The rising time is too long.");
			}

			usleep(delay);

			sumAmp = 0, sumPh = 0;
			for (i = 0; i < nb_acquisitions; i++) {
				pourcent = std::floor((i + j*nb_acquisitions) / static_cast<float>(nb_acquisitions * scanning_frequencies.size())*10000)/100;
				std::cerr << "\rFrequency " << f << " Hz (" << pourcent << "%)    " << std::flush;

				// Acquisition sur les channels 1 et 2 avec le trigger sur le channel 1
				acquisitionChannels1_2(signal1, signal2, RP_T_CH_1);

				// Fenêtrage des signaux
				windowed_signal1 = window.apply(signal1);
				windowed_signal2 = window.apply(signal2);
				
				// démodulation des signaux
				dem.apply(signal1, amplitude_demodulated1, phase_demodulated1, true);
				dem.apply(signal2, amplitude_demodulated2, phase_demodulated2, true);

				if (mode_debug) {
					for (size_t k = 0; k < BUFFER_SIZE; k++) {
						// Sauvegarde des signaux
						bigSignal1[k + i*BUFFER_SIZE] = signal1[k];
						bigSignal2[k + i*BUFFER_SIZE] = signal2[k];

						bigAmplitudeDemodulated1[k + i*BUFFER_SIZE] = amplitude_demodulated1[k];
						bigAmplitudeDemodulated2[k + i*BUFFER_SIZE] = amplitude_demodulated2[k];

						bigPhaseDemodulated1[k + i*BUFFER_SIZE] = phase_demodulated1[k];
						bigPhaseDemodulated2[k + i*BUFFER_SIZE] = phase_demodulated2[k];

						// Calculer la moyenne de l'ampltitude et de la phase après le temps de montée
						if (k >= indexRisingTime) {
							sumAmp += amplitude_demodulated2[k];
							sumPh  += (phase_demodulated2[k] - phase_demodulated1[k]);
						}
					}
				} else {
					for (size_t k = indexRisingTime; k < BUFFER_SIZE; k++) {
						sumAmp += amplitude_demodulated2[k];
						sumPh  += (phase_demodulated2[k] - phase_demodulated1[k]);
					}
				}
			}

			// calculer la moyenne de l'ampltitude après le temps de montée puis appliquer le filtre moyenneur
			amplitude = averaging_filter1.apply(sumAmp / static_cast<double>(sizePermanentRegime * nb_acquisitions));
			phase = averaging_filter2.apply(sumPh / static_cast<double>(sizePermanentRegime * nb_acquisitions));

			// on vérifie si l'amplitude est plus grande que l'amplitude maximale déjà enregistrée
			if (amplitude > amplitude_max) {
				amplitude_max = amplitude;
				amplitude_max_frequency = f;
			}
			// on vérifie si la phase est plus grande que la phase maximale déjà enregistrée
			if (phase > phase_max) {
				phase_max = phase;
				phase_max_frequency = f;
			}

			amplitude_of_movement.push_back(amplitude);
			phase_of_movement.push_back(phase);

			/* Sauvgarde des données */
			if (mode_debug) {
				bigSignal1.setName("signal1_" + std::to_string(static_cast<int>(f)));
				bigSignal2.setName("signal2_" + std::to_string(static_cast<int>(f)));
				std::vector<Signal> bigSignals = {bigSignal1, bigSignal2};
				bigAmplitudeDemodulated1.setName("amplitude_demodulated1_" + std::to_string(static_cast<int>(f)));
				bigAmplitudeDemodulated2.setName("amplitude_demodulated2_" + std::to_string(static_cast<int>(f)));
				std::vector<Signal> amplitudes_demodulated = {bigAmplitudeDemodulated1, bigAmplitudeDemodulated2};
				bigPhaseDemodulated1.setName("phase_demodulated1_" + std::to_string(static_cast<int>(f)));
				bigPhaseDemodulated2.setName("phase_demodulated2_" + std::to_string(static_cast<int>(f)));
				std::vector<Signal> phases_demodulated = {bigPhaseDemodulated1, bigPhaseDemodulated2};
			
				if (f == scanning_frequencies[0]) {
					outFile1.writeSignals(bigSignals, true);
					outFile2.writeSignals(amplitudes_demodulated, true);
					outFile3.writeSignals(phases_demodulated, true);
				} else {
					outFile1.writeSignalsToEnd(bigSignals);
					outFile2.writeSignalsToEnd(amplitudes_demodulated);
					outFile3.writeSignalsToEnd(phases_demodulated);
				}
			}

			j++;
		}
		std::cerr << "\n";
			
		std::vector<Signal> sigOut1 = {scanning_frequencies, amplitude_of_movement};
		outFile4.writeSignals(sigOut1, false);
			
		std::vector<Signal> sigOut2 = {scanning_frequencies, phase_of_movement};
		outFile5.writeSignals(sigOut2, false);


		/* - - - - - - - - - - - - - - - - - - - - - - - */

		std::cerr << "+---- Write descriptions file ---+" << std::endl;

		std::ostringstream oss;
	
		oss << "[program]" << std::endl;
		oss << "type = module" << std::endl;
		oss << "name = frequencyScanning" << std::endl;
		oss << "debug = " << mode_debug << std::endl;
		oss << "[parameters]" << std::endl;
		oss << "# Acquisition parameters" << std::endl;
		oss << "trigger_level = " << trigger_level << std::endl;
		oss << "trigger_delay = " << trigger_delay << std::endl;
		oss << "points_per_period = " 	<< points_per_period << std::endl;
		oss << "decimation = "			<< DECIMATION << std::endl;
		oss << "buffsize = "			<< BUFFER_SIZE << std::endl;
		oss << "nb_acquisitions = "	    << nb_acquisitions << std::endl;
		oss << "# Scanning parameters" << std::endl;
		oss << "frequency_min = "		<< frequency_min << std::endl;
		oss << "frequency_max = "		<< frequency_max << std::endl;
		oss << "number_of_frequencies_in_the_inteval = " << number_of_frequencies_in_the_inteval << std::endl;
		oss << "amplitude = "			<< output_amplitude << std::endl;
		oss << "offset = "				<< output_offset << std::endl;
		oss << "phase = "				<< output_phase << std::endl;
		oss << "delay = "				<< delay << std::endl;
		oss << "window_type = "			<< windowTypeToString(window_type) << std::endl;
		oss << "dem_filter_freq = "		<< dem_filter_freq << std::endl;
		oss << "[variables]" << std::endl;
		oss << "index_rising_time = " << indexRisingTime << std::endl;
		oss << "[measures]" << std::endl;
		oss << "amplitude_max = " << amplitude_max << std::endl;
		oss << "amplitude_max_frequency = " << amplitude_max_frequency << std::endl;
		oss << "phase_max = " << phase_max << std::endl;
		oss << "phase_max_frequency = " << phase_max_frequency << std::endl;
		oss << "[files]" << std::endl;
		oss << "file1 = " << filename1 << std::endl;
		oss << "file2 = " << filename2 << std::endl;
		oss << "file3 = " << filename3 << std::endl;
		oss << "file4 = " << filename4 << std::endl;
		oss << "file5 = " << filename5 << std::endl;
		CSVFile::writeDescriptions(oss.str());

		std::cerr << "+------------ END --------------+" << std::endl;

		result = 0;
	} catch (const std::exception &e) {
		std::cerr << "Error: " << e.what() << std::endl;
		result = 1;
	}
	
	rp_GenOutDisable(RP_CH_1);
	releaseAcquisition();
	rp_Release();

	return result;
}

int module_lockIn(const std::vector<std::string> &args) {
	/*int result;
	
	try {

		SetBufferSize(ADC_BUFFER_SIZE);
		SetDecimation(16);

		// proporiétés du balayage en fréquence
		int frequency = 100;
		int frequency_max = 100000;
		int number_of_frequencies_in_the_inteval = 40;

		// propriétés du sinal généré
		float output_amplitude = 1.0f;
		float output_phase  = 0;
		float output_offset = 0;
		
		// propriétés acquisition
		int points_per_period = 100;
		bool hasSetDecimation = false;
		int nb_acquisitions = 10; // nombre d'acquisitions à effectuer pour chaque fréquence
		int delay = 1000;

		// propriété démodulation
		double dem_filter_freq = 1e3;

		// propriété de la fenêtre
		WindowType window_type = WindowType::Rectangular;

		if (args.size() >= 1) {
			for (auto param : args) {
				if (param == "help") {
					std::cerr << "\033[4;0mHelp message\033[0m" << std::endl;
					std::cerr << "Details:" << std::endl;
					std::cerr << "  This module performs a frequency sweep, generating a sequence of" << std::endl;
					std::cerr << "  frequencies on a logarithmic scale at the output of the card," << std::endl;
					std::cerr << "  then performing an acquisition at the input of the card." << std::endl;
					std::cerr << "  " << std::endl;
					std::cerr << "Possibilities of utilisation : " << std::endl;
					std::cerr << "  Logarithmic scale for frequency scanning : " << std::endl;
					std::cerr << "    frequency_min=<integer>; fmin=<integer>" << std::endl;
					std::cerr << "      details: this is the minimum frequency of the frequency sweep" << std::endl;
					std::cerr << "      note: this argument is optional, and if not entered, the default value is " << frequency_min << std::endl;
					std::cerr << "    frequency_max=<integer>; fmax=<integer>" << std::endl;
					std::cerr << "      details: this is the maximum frequency of the frequency sweep" << std::endl;
					std::cerr << "      note: this argument is optional, and if not entered, the default value is " << frequency_max << std::endl;
					std::cerr << "    number_of_frequencies_in_the_inteval=<integer>; nfi=<integer>" << std::endl;
					std::cerr << "      details: this is the number of frequencies to scan on the frequency sweep" << std::endl;
					std::cerr << "      note: this argument is optional, and if not entered, the default value is " << number_of_frequencies_in_the_inteval << std::endl;
					std::cerr << "  Generator properties : " << std::endl;
					std::cerr << "    amplitude=<valu>; a=<value>; " << std::endl;
					std::cerr << "      details: this is the amplitude of the signal generated by the card" << std::endl;
					std::cerr << "      note: this argument is optional, and if not entered, the default value is " << output_amplitude << std::endl;
					std::cerr << "    offset=<valeur>; off=<valeur>; " << std::endl;
					std::cerr << "      details: this is the offset of the signal generated by the card" << std::endl;
					std::cerr << "      note: this argument is optional, and if not entered, the default value is " << output_offset << std::endl;
					std::cerr << "    phase=<value>; ph=<value>; " << std::endl;
					std::cerr << "      details: this is the phase of the signal generated by the card" << std::endl;
					std::cerr << "      note: this argument is optional, and if not entered, the default value is " << output_phase << std::endl;
					std::cerr << "  RP properties : " << std::endl;
					std::cerr << "    buffer_size=<integer>; \tbs=<integer>; " << std::endl;
					std::cerr << "      details: this is the buffer size of the acquisition signal" << std::endl;
					std::cerr << "      note: this argument is optional, and if not entered, the default value is " << ADC_BUFFER_SIZE << std::endl;
					std::cerr << "  Acquisition properties : " << std::endl;
					std::cerr << "    delay=<integer µs>" << std::endl;
					std::cerr << "      details: this is the delay between the end of the generation and the start of the acquisition" << std::endl;
					std::cerr << "      note: this argument is optional, and if not entered, the default value is " << delay << std::endl;
					std::cerr << "    window_type=<string>; \twindow=<string>; " << std::endl;
					std::cerr << "      details: this is the type of window to apply to the acquisition signal" << std::endl;
					std::cerr << "      note: this argument is optional, and if not entered, the default value is " << windowTypeToString(window_type) << std::endl;
					std::cerr << "    dem_filter_freq=<integer>; \tdff=<integer>; " << std::endl;
					std::cerr << "      details: this is the frequency of the low pass filter to apply to the demodulation" << std::endl;
					std::cerr << "      note: this argument is optional, and if not entered, the default value is " << dem_filter_freq << std::endl;
					std::cerr << "    points_per_period=<integer>; \tppp=<integer>; " << std::endl;
					std::cerr << "      details: this is the number of points per period of the signal" << std::endl;
					std::cerr << "      note: this argument is optional, and if not entered, the default value is " << points_per_period << std::endl;
					std::cerr << "    decimation=<integer>; \tdec=<integer>; " << std::endl;
					std::cerr << "      details: this is the decimation factor of the acquisition signal" << std::endl;
					std::cerr << "      note: this argument is optional, and if not entered, the default value is " << points_per_period << std::endl;
					std::cerr << "    nb_acquisitions=<integer>; \tnba=<integer>; " << std::endl;
					std::cerr << "      details: this is the number of acquisitions to perform by frequency in sweep frequencies" << std::endl;
					std::cerr << "      note: this argument is optional, and if not entered, the default value is " << nb_acquisitions << std::endl;
					return 0;
				} else {
					// Parse other arguments
					size_t pos = param.find('=');
					if (pos != std::string::npos) {
						std::string name = param.substr(0, pos);
						std::string value = param.substr(pos + 1);

						if (name == "frequency_min" || name == "fmin") {
							frequency_min = std::abs(convertToInteger(value));
						} else if (name == "frequency_max" || name == "fmax") {
							frequency_max = std::abs(convertToInteger(value));
						} else if (name == "number_of_frequencies_in_the_inteval" || name == "nfi") {
							number_of_frequencies_in_the_inteval = std::abs(std::stoi(value));
						} else if (name == "amplitude" || name == "a") {
							output_amplitude = std::stof(value);
						} else if (name == "phase" || name == "ph") {
							output_phase = std::stof(value);
						} else if (name == "offset" || name == "off") {
							output_offset = std::stof(value);
						} else if (name == "delay") {
							delay = std::abs(convertToInteger(value));
						} else if (name == "window" || name == "win") {
							window_type = stringToWindowType(value);
						} else if (name == "dem_filter_freq" || name == "dff") {
							dem_filter_freq = std::abs(convertToInteger(value));
						} else if (name == "points_per_period" || name == "ppp") {
							points_per_period = convertToInteger(value);
						} else if (name == "decimation" || name == "dec") {
							hasSetDecimation = true;
							SetDecimation(std::stoi(value));
						} else if (name == "buffsize" || name == "bs") {
							SetBufferSize(convertToInteger(value));
						} else if (name == "nb_acquisitions" || name == "nba") {
							nb_acquisitions = std::abs(convertToInteger(value));
						} else {
							std::cerr << "Error: invalid argument " << param << std::endl;
							return 1;
						}

					} else {
						std::cerr << "Error: invalid argument " << param << std::endl;
						return 1;
					}
				}
			}
		}

		//auto startTime = std::chrono::high_resolution_clock::now();

		// Print error, if rp_Init() function failed
		if (rp_InitReset(true) != RP_OK) {
			std::cerr << "Error: Rp api init failed!";
			return 1;
		}


	}*/
    return 0;
}
